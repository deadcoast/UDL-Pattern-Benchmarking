
<!DOCTYPE html>
<html>
<head>
    <title>Grammar Dependency Flow</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <div class="container">
        <h1>Grammar Dependency Flow Diagram</h1>
        
        <div class="controls">
            <label>
                <input type="checkbox" id="showSCC" onchange="toggleSCC()" checked> Show Strongly Connected Components
            </label>
            <label>
                Layout: 
                <select id="layout" onchange="changeLayout()">
                    <option value="sankey">Sankey</option>
                    <option value="hierarchical">Hierarchical</option>
                    <option value="circular">Circular</option>
                </select>
            </label>
        </div>
        
        <div class="visualization-panel">
            <svg id="dependency-svg" width="900" height="600"></svg>
        </div>
        
        <div class="visualization-panel">
            <h3>Strongly Connected Components</h3>
            <div id="scc-info"></div>
        </div>
        
        <div class="tooltip"></div>
    </div>

    <script>
        const dependencies = {"nodes": [{"id": "'7'", "group": 0}, {"id": "'+'", "group": 1}, {"id": "'*'", "group": 2}, {"id": "'0'", "group": 3}, {"id": "|", "group": 4}, {"id": "'1'", "group": 5}, {"id": "'2'", "group": 6}, {"id": "'3'", "group": 7}, {"id": "'4'", "group": 8}, {"id": "'5'", "group": 9}, {"id": "'6'", "group": 10}, {"id": "'8'", "group": 11}, {"id": "'9'", "group": 12}, {"id": "}", "group": 13}, {"id": "digit", "group": 14}, {"id": "+", "group": 15}, {"id": "number", "group": 16}, {"id": "'('", "group": 17}, {"id": "')'", "group": 18}, {"id": "(", "group": 19}, {"id": "'/'", "group": 20}, {"id": ")", "group": 21}, {"id": "*", "group": 22}, {"id": "'-'", "group": 23}, {"id": "expression", "group": 24}, {"id": "term", "group": 24}, {"id": "factor", "group": 24}], "links": [{"source": "expression", "target": "term"}, {"source": "expression", "target": "("}, {"source": "expression", "target": "'+'"}, {"source": "expression", "target": "|"}, {"source": "expression", "target": "'-'"}, {"source": "expression", "target": ")"}, {"source": "expression", "target": "*"}, {"source": "digit", "target": "'0'"}, {"source": "digit", "target": "|"}, {"source": "digit", "target": "'1'"}, {"source": "digit", "target": "'2'"}, {"source": "digit", "target": "'3'"}, {"source": "digit", "target": "'4'"}, {"source": "digit", "target": "'5'"}, {"source": "digit", "target": "'6'"}, {"source": "digit", "target": "'7'"}, {"source": "digit", "target": "'8'"}, {"source": "digit", "target": "'9'"}, {"source": "digit", "target": "}"}, {"source": "term", "target": "factor"}, {"source": "term", "target": "("}, {"source": "term", "target": "'*'"}, {"source": "term", "target": "|"}, {"source": "term", "target": "'/'"}, {"source": "term", "target": ")"}, {"source": "term", "target": "*"}, {"source": "factor", "target": "number"}, {"source": "factor", "target": "|"}, {"source": "factor", "target": "'('"}, {"source": "factor", "target": "expression"}, {"source": "factor", "target": "')'"}, {"source": "number", "target": "digit"}, {"source": "number", "target": "+"}], "sccs": [["'7'"], ["'+'"], ["'*'"], ["'0'"], ["|"], ["'1'"], ["'2'"], ["'3'"], ["'4'"], ["'5'"], ["'6'"], ["'8'"], ["'9'"], ["}"], ["digit"], ["+"], ["number"], ["'('"], ["')'"], ["("], ["'/'"], [")"], ["*"], ["'-'"], ["expression", "term", "factor"]], "topo_order": ["'7'", "'+'", "'*'", "expression", "'6'", "*", "+", "(", "digit", "'2'", "term", "'/'", "|", "'5'", "'8'", "'4'", "factor", "'('", "'3'", ")", "'0'", "')'", "'-'", "}", "'1'", "'9'", "number"]};
        
        let currentLayout = 'sankey';
        let showSCCs = true;
        
        function initializeDependencyFlow() {
            updateVisualization();
            displaySCCInfo();
        }
        
        function updateVisualization() {
            const svg = d3.select("#dependency-svg");
            svg.selectAll("*").remove();
            
            switch(currentLayout) {
                case 'sankey':
                    createSankeyDiagram(svg);
                    break;
                case 'hierarchical':
                    createHierarchicalLayout(svg);
                    break;
                case 'circular':
                    createCircularLayout(svg);
                    break;
            }
        }
        
        function createSankeyDiagram(svg) {
            const width = 900;
            const height = 600;
            const margin = { top: 20, right: 20, bottom: 20, left: 20 };
            
            // Prepare data for Sankey
            const sankeyData = {
                nodes: dependencies.nodes.map(d => ({ ...d })),
                links: dependencies.links.map(d => ({ ...d }))
            };
            
            const sankey = d3.sankey()
                .nodeWidth(15)
                .nodePadding(10)
                .extent([[margin.left, margin.top], [width - margin.right, height - margin.bottom]]);
            
            const { nodes, links } = sankey(sankeyData);
            
            // Add links
            svg.append("g")
                .selectAll("path")
                .data(links)
                .enter().append("path")
                .attr("d", d3.sankeyLinkHorizontal())
                .attr("stroke", d => showSCCs ? d3.schemeCategory10[d.source.group % 10] : "#999")
                .attr("stroke-width", d => Math.max(1, d.width))
                .attr("fill", "none")
                .attr("opacity", 0.5);
            
            // Add nodes
            svg.append("g")
                .selectAll("rect")
                .data(nodes)
                .enter().append("rect")
                .attr("x", d => d.x0)
                .attr("y", d => d.y0)
                .attr("height", d => d.y1 - d.y0)
                .attr("width", d => d.x1 - d.x0)
                .attr("fill", d => showSCCs ? d3.schemeCategory10[d.group % 10] : "#2196f3")
                .on("mouseover", showNodeTooltip)
                .on("mouseout", hideTooltip);
            
            // Add labels
            svg.append("g")
                .selectAll("text")
                .data(nodes)
                .enter().append("text")
                .attr("x", d => d.x0 < width / 2 ? d.x1 + 6 : d.x0 - 6)
                .attr("y", d => (d.y1 + d.y0) / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", d => d.x0 < width / 2 ? "start" : "end")
                .text(d => d.id);
        }
        
        function createHierarchicalLayout(svg) {
            const width = 900;
            const height = 600;
            
            // Create hierarchy based on topological order
            const levels = {};
            dependencies.topo_order.forEach((node, i) => {
                const level = Math.floor(i / Math.ceil(dependencies.topo_order.length / 5));
                if (!levels[level]) levels[level] = [];
                levels[level].push(node);
            });
            
            const levelHeight = height / Object.keys(levels).length;
            
            // Position nodes
            const nodePositions = {};
            Object.keys(levels).forEach(level => {
                const levelNodes = levels[level];
                const levelWidth = width / (levelNodes.length + 1);
                levelNodes.forEach((node, i) => {
                    nodePositions[node] = {
                        x: (i + 1) * levelWidth,
                        y: (parseInt(level) + 0.5) * levelHeight
                    };
                });
            });
            
            // Draw links
            svg.selectAll(".dep-link")
                .data(dependencies.links)
                .enter().append("line")
                .attr("class", "dep-link")
                .attr("x1", d => nodePositions[d.source].x)
                .attr("y1", d => nodePositions[d.source].y)
                .attr("x2", d => nodePositions[d.target].x)
                .attr("y2", d => nodePositions[d.target].y)
                .attr("stroke", "#999")
                .attr("stroke-width", 2)
                .attr("marker-end", "url(#arrowhead)");
            
            // Add arrowhead marker
            svg.append("defs").append("marker")
                .attr("id", "arrowhead")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 8)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", "#999");
            
            // Draw nodes
            svg.selectAll(".dep-node")
                .data(dependencies.nodes)
                .enter().append("circle")
                .attr("class", "dep-node")
                .attr("cx", d => nodePositions[d.id].x)
                .attr("cy", d => nodePositions[d.id].y)
                .attr("r", 20)
                .attr("fill", d => showSCCs ? d3.schemeCategory10[d.group % 10] : "#2196f3")
                .on("mouseover", showNodeTooltip)
                .on("mouseout", hideTooltip);
            
            // Add labels
            svg.selectAll(".dep-label")
                .data(dependencies.nodes)
                .enter().append("text")
                .attr("class", "dep-label")
                .attr("x", d => nodePositions[d.id].x)
                .attr("y", d => nodePositions[d.id].y + 35)
                .attr("text-anchor", "middle")
                .text(d => d.id);
        }
        
        function createCircularLayout(svg) {
            const width = 900;
            const height = 600;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 2 - 50;
            
            // Position nodes in circle
            const nodePositions = {};
            dependencies.nodes.forEach((node, i) => {
                const angle = (i / dependencies.nodes.length) * 2 * Math.PI;
                nodePositions[node.id] = {
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                };
            });
            
            // Draw links as curves
            svg.selectAll(".dep-link")
                .data(dependencies.links)
                .enter().append("path")
                .attr("class", "dep-link")
                .attr("d", d => {
                    const source = nodePositions[d.source];
                    const target = nodePositions[d.target];
                    const dx = target.x - source.x;
                    const dy = target.y - source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy) * 0.3;
                    return `M${source.x},${source.y}A${dr},${dr} 0 0,1 ${target.x},${target.y}`;
                })
                .attr("stroke", "#999")
                .attr("stroke-width", 2)
                .attr("fill", "none")
                .attr("marker-end", "url(#arrowhead)");
            
            // Add arrowhead marker
            svg.append("defs").append("marker")
                .attr("id", "arrowhead")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 8)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", "#999");
            
            // Draw nodes
            svg.selectAll(".dep-node")
                .data(dependencies.nodes)
                .enter().append("circle")
                .attr("class", "dep-node")
                .attr("cx", d => nodePositions[d.id].x)
                .attr("cy", d => nodePositions[d.id].y)
                .attr("r", 15)
                .attr("fill", d => showSCCs ? d3.schemeCategory10[d.group % 10] : "#2196f3")
                .on("mouseover", showNodeTooltip)
                .on("mouseout", hideTooltip);
            
            // Add labels
            svg.selectAll(".dep-label")
                .data(dependencies.nodes)
                .enter().append("text")
                .attr("class", "dep-label")
                .attr("x", d => nodePositions[d.id].x)
                .attr("y", d => nodePositions[d.id].y + 25)
                .attr("text-anchor", "middle")
                .text(d => d.id);
        }
        
        function displaySCCInfo() {
            const sccInfo = document.getElementById("scc-info");
            sccInfo.innerHTML = "";
            
            dependencies.sccs.forEach((scc, i) => {
                const div = document.createElement("div");
                div.innerHTML = `<strong>Component ${i + 1}:</strong> ${scc.join(", ")}`;
                div.style.color = d3.schemeCategory10[i % 10];
                div.style.margin = "5px 0";
                sccInfo.appendChild(div);
            });
        }
        
        function toggleSCC() {
            showSCCs = document.getElementById("showSCC").checked;
            updateVisualization();
        }
        
        function changeLayout() {
            currentLayout = document.getElementById("layout").value;
            updateVisualization();
        }
        
        function showNodeTooltip(event, d) {
            const tooltip = d3.select(".tooltip");
            tooltip.transition().duration(200).style("opacity", .9);
            tooltip.html(`Node: ${d.id}<br/>Group: ${d.group}`)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px");
        }
        
        function hideTooltip() {
            d3.select(".tooltip").transition().duration(500).style("opacity", 0);
        }
        
        // Initialize on load
        initializeDependencyFlow();
    </script>
</body>
</html>
        